Docstatus 
Frappe uses the concept of a "Docstatus" to keep track of the status of transactions. The docstatus will always have one of the following three values:

Draft (value: 0)
Submitted (value: 1)
Cancelled (value: 2)
Documents that are _not submittable_ will always remain in the "draft" state. Documents that are _submittable_ can optionally proceed from the draft state to the "submitted", and then to the "cancelled" state.

Documents in the submitted and cancelled state cannot be edited, with one execption: for individual fields we can explicitly allow edits, even when the document is in the submitted state.

In the backend code we have a helper class DocStatus that can be used as follows:

import frappe
from frappe.model.docstatus import DocStatus

draft_invoice_names = frappe.get_list(
 "Sales Invoice",
 filters={"docstatus": DocStatus.draft()},
 pluck="name"
)

invoice_doc = frappe.get_doc("Sales Invoice", draft_invoice_names[0])
invoice_doc.docstatus == DocStatus.draft() # -> True
invoice_doc.docstatus.is_draft() # -> True
invoice_doc.docstatus.is_submitted() # -> False
invoice_doc.docstatus.is_cancelled() # -> False

invoice_doc.submit()
invoice_doc.docstatus == DocStatus.submitted() # -> True
invoice_doc.docstatus.is_draft() # -> False
invoice_doc.docstatus.is_submitted() # -> True
invoice_doc.docstatus.is_cancelled() # -> False

invoice_doc.cancel()
invoice_doc.docstatus == DocStatus.cancelled() # -> True
invoice_doc.docstatus.is_draft() # -> False
invoice_doc.docstatus.is_submitted() # -> False
invoice_doc.docstatus.is_cancelled() # -> True
The docstatus gets stored as an integer value in each Doctype table of the database.

Module 
A DocType will always belong to a module, to enable easier grouping of related models. Frappe comes with a lot of built-in modules. For e.g

Core - contains doctypes like DocType, DocField, Report, System Settings, etc
Desk - contains doctypes like ToDo, Event, Note, Kanban Board, etc
Email - contains doctypes like Email Account, Newsletter, Email Group, etc
Modules also helps in grouping of code files in directories. The controller files generated by a DocType will live in it's respective Module directory.

frappe
├── commands
├── config
├── core
│   ├── doctype
│   │   ├── doctype
│   │   ├── docfield
│   │   ├── report
│   │   ├── system_settings
│   │   ├── ...
│   │   └── ...
│   ├── page
│   ├── report
│   └── web_form
├── desk
│   ├── doctype
│   │   ├── ...
│   │   ├── event
│   │   ├── kanban_board
│   │   ├── note
│   │   └── todo
│   ├── form
│   ├── page

Virtual DocField 
A Virtual DocField is a dynamic attribute of a given Document (or Record). It's a calculated attribute that isn't stored in the site database. This could be used for representing values that may be functions of other static Document attributes.

Person Record
Person Form

The age of a person is a function of their date of birth ie if you know a person's birth day, you can figure out their age. Age is also a continuous value; it may change every year, or month, or day, even hour depending on what type of granularity you wish to have. Another attribute is a Person's name. Most common implementations will have a First, Middle and a Last Name, and for the view it would be all of them together like "Jon Raphael Doe". Although saving the full name as a separate attribute may not make so much sense when the strings can be easily concatenated. These are a couple of instances where Virtual DocFields make more sense.

Person DocType
Person DocType

Here we've added three fields to Person; two for First and Last names which are stored in the site database, and one that utilizes this data to populate the third field "Full Name". In this instance, the options field takes input for the return value of the respective virtual field.

Full Name - Virtual DocField
Person DocType - DocField

We discussed the possibility of fields that depend on attributes in the system so far. But this could easily extend to something that doesn't depend on your DocType data alone. You may also want to fetch the statuses of multiple external services in their place, or anything else that you can map here instead.

How to use Virtual DocFields 
The steps involved in making this work are:

1. Define a Virtual DocField 
Defining a Virtual DocField is fairly straight forward. Just checking on the "Virtual" check box under the DocField's configuration does this. Virtual DocFields don't create a corresponding column in the DocType's table. This makes the field "Read Only" in the Form Views.

Note: Avoid making existing DocFields virtual unless you know what you're doing

2. Define a source for the field 
The first step only adds a sort of a placeholder for the values. Without adding some code that dictates what the field should show, there's no field itself. There's two ways of doing this:

By extending the DocType controllers
Adding a Python property with the same name as the virtual field should do this. This is the most flexible way to do this; you could daisy chain an internal API request, or fetch the data from multiple data sources, sky is the limit.

class Person(Document):
 @property
 def age(self):
 return frappe.utils.now_datetime() - self.creation
Using the DocField.options
This is a bit more restrictive given it allows you to write code directly from Desk. Utils allowed in Server Scripts and Document attributes can be accessed through this. Equivalent of the above property maybe as follows:

frappe.utils.now_datetime() - self.creation
The above mentioned Person.full_name example uses Python's f-string feature to achive this in a similar way.

Note: This should be preferred for relatively smaller scripting. Lookout for in-compatible types errors while using this

Impact on internals 
If you're wellversed with the physics of the Frappe world, this feature will appear quite predictable.

Backend API 
The DatabaseQuery methods or Database APIs will not return virtual values since they don't live in the Site Database.



REST API 
The /api/method/frappe.desk.form.load.getdoc and /api/resource APIs utilize Document.get_valid_dict which will compute Virtual values too. These APIs are used to render the Desk Form views too.



Database 
There's no footprint of virtual fields in the respective DocType's table. However, you may find corresponding records to give some evidence of their existence in the Custom Field, DocField tables that store DocType's Meta.



Virtual Tables on Non-virtual DocTypes 
Note: This feature is only available in nightly (v16) version. This feature is considered experimental.

A virtual child table is a virtual field of type "Table" that is computed at runtime. It behaves like a normal child table in many respects:

The virtual child table appears in the form (grid) under the parent document.
Its rows are computed dynamically (e.g. via a cached property or descriptor).
It is read-only (you cannot write into it through the usual ORM methods).
The parent DocType does not persist these child rows; they exist only in memory.
The descriptor method for the virtual table can return either raw dictionaries or Document instances.
When loading from the database, the virtual child table’s descriptor is triggered to populate the children rows.
Virtual tables are useful for displaying computed/aggregated data or summary of related data stored elsewhere.

Defining a Virtual Child Table 
To define a virtual child table, you add a new field entry in the parent DocType with "is virtual" set to 1. Logic for dynamically fetching the virtual table has to be defined as a cached property on the DocType controller.

Note: You MUST NOT use @property for virtual tables, only @cached_property and other equivalent non-data descriptors are supported.

class User(…) :
    # This is a cached_property (or a non-data descriptor) returning computed rows
    @cached_property
    def virtual_sessions(self):
        # return a list of dicts or list of Document instances
        sessions = get_session_logs(self.name)
        return sessions
In this example, when a User record is loaded, the framework invokes User.virtual_sessions to fetch child rows, then initializes a virtual child table virtual_sessions in the form context.

Field Types 
There are variety of fieldtypes available in Frappe Framework. Each one has its own use case and can be used to input and store different types of data in a document. Fieldtypes are used to render components in desk as well as web forms.

Field Types Dropdown Menu

Data 
The data field will be a simple text field. It allows you to enter a value of up to 140 characters, making this the most generic field type.

You can enable validations for the following types of data:

Name
Email
Phone
URL
by setting the options to "Name", "Email", "Phone" or "URL" respectively.

Data field types

Set the options to "IBAN" to enable formatting in blocks of 4 characters.

Link 
Link field is connected to another master from where it fetches data. For example, in the Quotation master, the Customer is a Link field. To know more, click here.

Dynamic Link 
Dynamic Link field is one which can search and hold value of any document/doctype. Click here to learn how Dynamic Link Field functions.

Check 
This will enable you to have a checkbox here. You can set the Default value to 1 and it will be checked by default.

Check Field Preview Check Field Edit

Select 
Using the field type "Select", you can create a drop-down field. You can specify all selectable values in the Options field, each value separated by a new line.

One of the selectable values can be copied into the Default field. This value will then be selected by default in a new form.

If you enable the Sort Options checkbox, values will be displayed in alphabetical order (in the user's language).

The following screenshot shows how a "Select" field can be defined in the DocType or via Customize Form:

define_select_field

And this is how it will be rendered in a new form:

use_select_field

Table 
With a "Table" field, you can render another DocType as a child table within your form.

First, you'll have to choose or define a DocType that has the Checkbox Is Child Table enabled. Then you can add a field of type "Table" and paste the name of your child table DocType into the Options field.

For example, ERPNext defines a child DocType called "Purchase Receipt Item" with Is Child Table enabled:

define_child_table_doctype

Another DocType called "Purchase Receipt" has a field of type "Table", with Options set to above child doctype "Purchase Receipt Item":

define_child_table_field

Finally, the child table will be rendered in the Purchase Receipt form:

child_table_in_form

Attach 
Attach field allows you to browse a field from the File Manager and attach the same herein.

Field Types

Attach Image 
Attach Image is a field wherein you will be allowed to attach Images of the format jpeg, png, etc. This becomes the Image representing that particular DocType. For e.g., you would want the image of an Item in its DocType, you can choose your field to be an Attach Image Field.

Text Editor 
Text Editor is a text field and renders a WYSIWYG editor for input. It has various text-formatting options.

Field Types

Date 
This field will enable you to enter the Date in this field.

Field Types

Date and Time 
This field will give you a date and time picker. The current date and time (as provided by your computer) are set by default.

Barcode 
In this field, you can specify the field as Barcode which will allow you to enter a Barcode number. Once you do that, the Barcode would automatically get generated against the number.

barcode

Button 
This field lets you place a button in a document. This can be used to perform specific actions like publishing a blog post, triggering an action etc.

Code 
This fieldtype can be used to take code as input. A code editor is rendered in the document form. Optionally, you can provide a langauge in the fieldtype options to enable syntax highlighting. For example, below is a Code type field with options set to Python:

You can enable basic syntax validations for following languages by setting "Option".

Python (for scripts)
PythonExpression (for simple one-line expressions that must evaluate to a value) E.g. Assignment Rule condition
Example of differences between Python and PythonExpression:

variable = 42 is a valid Python code but not a valid PythonExpression since the assignment doesn't evaluate to any value.
variable == 42 is both valid Python code and valid PythonExpression as the expresion can evaluate to some value.
Field Types

Color 
This will let the user input a color via a rendered color picker or directly input a hexadecimal color.

Field Types

Column Break 
This is a 'meta' fieldtype that does not store any input data but can be used to indicate a column break in the document view or form.

For example,

Field Types

will result into:

Field Types

Currency 
Currency field holds numeric value, like Item Price, Amount, etc. Currency field can have value up to six decimal places. Also, you can have a currency symbol being shown for the currency field.

Float 
Float field carries numeric value, up to nine decimal places.

Geolocation 
A Geolocation field will show a map view on which you can draw polygons, lines, and points. The data is stored as a GeoJSON feature_collection.

If you add a Geolocation field with the exact field name "location", you will get an additional map view (the equivalent of list view, but on a map). By the way, this also works if you create two separate fields named "latitude" and "longitude".

Note: Frappe uses the "Leaflet" library which stores coordinates as [latitude, longitude] which is the reverse of what GeoJSON usually does.

HTML 
This will render the content entered in Options as HTML in the document form or view page. Here is an example:

Field Types

will result into:

Field Types

Image 
Image field will render an image file selected in another attach field.

For the Image field, under Option (in Doctype), a field name should be provided where the image file is attached. By referring to the value in that field, the image will be a reference in the Image field.

Field Types

will result into:

Field Types

Int (Integer) 
The integer field holds numeric value, without decimal place.

Small Text 
Small Text field carries text content and has more character limit than the Data field.

Long Text 
You can define your field to a Long Text Field when you would want to enter data with an unlimited character limit.

Text 
This field type would allow you to add text in the field. The character limit in Small text, Long text and Text fields shall be determined based on the Relational Database Management System.

Markdown Editor 
This field will allow you to add the text in markdown. This fieldtype also provides a Preview view of rendered HTML:

Field Types

when preview is clicked:

Field Types

Password 
The password field will have decoded value in it. This type of field can be used to store sensitive data like passwords, pass phrases, secret keys etc.

Percent 
You can define the field as a Percentage field which in the background will be calculated as a percentage.

Rating 
This field can be used to display an interactive star rating input. The default star count shown is 5, however, this can easily be changed by entering a number ranging from 3 - 10 in the options field for that particular rating field.

Check Field Edit

You can also provide half ratings e.g 3.5 out of 5.

Half Rating

Read Only 
Read Only field will carry data fetched from another form which will be non-editable. You should set Read Only as field type if its source for value is predetermined.

Section Break 
Section Break is used to divide the form into multiple sections. Any fields that follow (and before any other Section Break) a Section Break field will be part of this new section.

Field Types

Tab Break 
Tab Break is used to divide the form into multiple tabs. Any field that follow till the next Tab Break will be the part of this new tab.

Tabs

Note: If the fields table of a DocType is not started with a Tab Break, a default Tab Break named Details will be used. This happens only if a DocType has atleast one Tab Break in the fields table.

Signature 
You can define the field to be a Signature field wherein you can add the Digital Signature in this field. Read documentation for Signature Field to know more.

Table MultiSelect 
This is a combination of 'Link' type and 'Table' type fields. Instead of a child table with 'Add Row' button, in one field multiple values can be selected.

Time 
This is a Time field where you can define the Time in the field.

Duration 
You can use the Duration field if you want to define a timespan.

If you don't want to track duration in terms of days or seconds, you can enable "Hide Days" and "Hide Seconds" options respectively in your Form. One day is equivalent to 24 hours.

JSON 
This creates a JSON type column in your database. Also adds syntax highlighting for Desk controls.


Naming 
All DocTypes in Frappe have a primary key called name. This is the unique id by which you will be finding records and manipulating them using the ORM. You can configure how docs should be named when a new document is created. The following are the ways you can setup naming in a DocType.

DocType autoname 
You can set the name by the autoname property of the DocType.

1. field:[fieldname] 
The doc name is fetched from the value of the field provided.

naming by field

2. [series] 
You can provide a naming pattern which will be incremented automatically. For e.g, if you set it as PRE.#####, the first document created will have the name as PRE00001, and second one will be PRE00002 and so on.

naming by series

3. naming_series: 
The naming pattern is derived from a field in the document. For e.g, you have a field naming_series in your document and it's value is set as PRE.#####, then that will be the pattern used for generating the name. This value can change per document. So the next document can have a different pattern.

This works only if you have a field called naming_series in your DocType.

naming by series by field

4. Prompt 
If you set it as Prompt, the name is required to be filled in manually.

naming by prompt

5. Format 
This is the most flexible one when it comes to configuring your naming schemes.

Let's say we have

EXAMPLE-{MM}-test-{fieldname1}-{fieldname2}-{#####}
naming by format

Everything outside the curly braces are plain text. Keywords inside the curly braces will be evaluated based on what they represent. In this case:

MM: will be replaced by the current month
fieldname1: will be replaced by the value of fieldname1 in the document
#####: will generate a series, which starts with 00001
So the final name may look like, EXAMPLE-02-test-value1-value2-00001

By Controller Method 
You can also define a name programatically by declaring an autoname method in the controller class. Example

from frappe.model.naming import getseries

class Project(Document):
 def autoname(self):
 # select a project name based on customer
 prefix = `P-{}-`.format(self.customer)
 self.name = getseries(prefix, 3)
By Document Naming Rule 
You can also create rules for naming DocTypes by creating Document Naming Rule

Document Naming Rule

You can create multiple Document Naming Rules for a particular doctype that can be applied selectively based on filters.

To define a Document Naming Rule you have to specify

Document Type it is being applied on
Priority of the rule (rules with higher priority will be applied first)
Conditions to apply the rule
Naming Rules
Numbering 
You can define various numbering prefixes for the rule based on the conditions defined. This is done by setting a prefix and the number of digits for that rule.

For example if you are creating a separate numbering for high priority todos:

Prefix: todo-high-
Digits: 3
Will lead to numbering like todo-high-001, todo-high-002 and so on.

Priority of Naming 
Naming priority is as follows

Document Naming Rule
autoname controller method.
autoname DocType property
Special Rules 
Child DocTypes do not follow naming rules
Amended documents have a suffix (-1, -2 etc) to the original document


DocField 
A DocField defines a property (or a field) of a DocType. You can define the column name, label, datatype and more for DocFields. For instance, a ToDo doctype has fields description, status and priority. These ultimately become columns in the database table tabToDo.

Example

The DocField stores meta-data about the field. Some of them are described below.

[
 {
 "label": "Description", // the value shown to the user (Form, Print, etc)
 "fieldname": "description", // the property name we refer in code, also the column name
 "fieldtype": "Text Editor", // the fieldtype which also decides how to store this value
 "reqd": 1 // whether this field is mandatory
 },
 {
 "label": "Status",
 "fieldname": "status",
 "fieldtype": "Select",
 "options": [
 "Open",
 "Pending",
 "Closed"
 ]
 },
 {
 "label": "Priority",
 "fieldname": "priority",
 "fieldtype": "Select",
 "options": [ // list of options for select
 "Low",
 "Medium",
 "High"
 ],
 "default": "Low" // the default value to be set
 },
 {
 "label": "Completed By",
 "fieldname": "completed_by",
 "fieldtype": "Link",
 "options": "User",
 "depends_on": "eval: doc.status == 'Closed'", // the condition on which this field's display depends
 },
 {
 "collapsible": 1,
 "collapsible_depends_on": "eval:doc.status!='Closed'", // determines if a Section Break field is collapsible
 "fieldname": "sb_details",
 "fieldtype": "Section Break",
 "label": "Details"
 },
 {
 "fieldname": "amount",
 "fieldtype": "Currency", // Currency field
 "label": "Amount",
 "non_negative": 1, // determines whether this field value can be negative
 "options": "INR",
 }
]
Similar to the depends_on property which determines whether a field will be displayed or not, in Version 12 we have introduced two new properties:

mandatory_depends_on: If this condition is satisfied, the field will be mandatory.
read_only_depends_on: If this condition is satisfied, the field will be read only.
Frappe comes with more than 30 different fieldtypes out-of-the-box. These fieldtypes serve a variety of use-cases. You can learn more about fieldtypes in the next page.

Controllers 
A Controller is a normal Python class which extends from frappe.model.Document base class. This base class is the core logic of a DocType. It handles how values are loaded from the database, how they are parsed and saved back to the database.

When you create a DocType named Person, a python file is created by the name person.py and the contents look like:

import frappe
from frappe.model.document import Document

class Person(Document):
    pass



All the fields are available to the class as attributes.

Controller Methods 
You can add custom methods to your Controller and it will be callable using the doc object. For example,

# controller class
class Person(Document):
    def get_full_name(self):
        """Returns the person's full name"""
        return f"{self.first_name} {self.last_name}"

# somewhere in your code
>>> doc = frappe.get_doc("Person", "000001")
>>> doc.get_full_name()
John Doe


Controller Hooks 
To add custom behaviour during the lifecycle of a document, we have controller hooks.

Method Name	Description	Insert	Save	Submit	Cancel	Update after submit
before_insert	This is called before a document is prepared for insertion.	X				
before_naming	This is called before the name property of the document is set.	X				
autoname	If defined in the controller, this method is used to set name property of the document.	X				
before_validate	This hook is called before validation, use this for auto setting missing values.	X	X	X		
validate	Use this method to throw any validation errors and prevent the document from saving.	X	X	X		
before_save	This method is called before the document is saved.	X	X			
before_submit	This method is called before the document is submitted.	X		X		
before_cancel	This method is called before the document is cancelled.				X	
before_update_after_submit	This method is called when doc fields are updated on submitted document.					X
db_insert	This method inserts document in database, do not override this unless you're working on virtual DocType.	X				
after_insert	This is called after the document is inserted into the database.	X				
db_update	This method updates document in database, do not override this unless you're working on virtual DocType.		X	X	X	X
on_update	This is called when values of an existing document is updated.	X	X	X		
on_submit	This is called when a document is submitted.			X		
on_cancel	This is called when a submitted document is cancelled.				X	
on_update_after_submit	This is called when a submitted document values are updated.					X
on_change	This is called when a document's values has been changed. This method is also called when db_set is performed, so operation performed in this method should be idempotent.	X	X	X	X	X
Apart from doc events for typical actions, you can also hook into other actions.

Method Name	Description
before_rename	This is called before a document is renamed.
after_rename	This is called after a document is renamed.
on_trash	This is called when a document is being deleted.
after_delete	This is called after a document has been deleted.
To use a controller hook, just define a class method with that name. For e.g

class Person(Document):
    def validate(self):
        if self.age <= 18:
            frappe.throw("Person's age must be at least 18")

    def after_insert(self):
        frappe.sendmail(recipients=[self.email], message="Thank you for registering!")


You can also override the pre-defined document methods to add your own behaviour if the hooks aren't enough for you. For e.g to override the save() method,

class Person(Document):
    def save(self, *args, **kwargs):
        super().save(*args, **kwargs) # call the base save method
        do_something() # eg: trigger an API call or a Rotating File Logger that "User X has tried updating this particular record"


There are a lot of methods provided by default on the doc object. You can find the complete list here.

1. Create a document 
To create a new document and save it to the database,

doc = frappe.get_doc({
    'doctype': 'Person',
    'first_name': 'John',
    'last_name': 'Doe'
})
doc.insert()

doc.name # 000001


2. Load a document 
To get an existing document from the database,

doc = frappe.get_doc('Person', '000001')

# doctype fields
doc.first_name # John
doc.last_name # Doe

# standard fields
doc.creation # datetime.datetime(2018, 9, 20, 12, 39, 34, 236801)
doc.owner # john.doe@frappeframework.com


Document 
A Document is an instance of a DocType. It usually maps to a single row in the database table. We refer to it as doc in code.

Example

Let's say we have a DocType ToDo with the following fields:

description
status
priority
Now, if we want to query a document from the database, we can use the ORM.

>>> doc = frappe.get_doc("ToDo", "0000001")
<todo: 0000001="">

>>> doc.as_dict()
{'name': '0000001',
 'owner': 'Administrator',
 'creation': datetime.datetime(2022, 3, 28, 18, 20, 23, 275229),
 'modified': datetime.datetime(2022, 3, 28, 18, 20, 23, 275229),
 'modified_by': 'Administrator',
 'docstatus': 0,
 'idx': 0,
 'status': 'Open',
 'priority': 'Medium',
 'color': None,
 'date': None,
 'allocated_to': None,
 'description': 'Test',
 'reference_type': None,
 'reference_name': None,
 'role': None,
 'assigned_by': 'Administrator',
 'assigned_by_full_name': 'Administrator',
 'sender': None,
 'assignment_rule': None,
 'doctype': 'ToDo'}


You get the values of description, status and priority, but you also get fields like creation, owner and modified_by which are fields added by default by the framework on all docs.

Type Annotations 
Introduced in Version 15.

Frappe support automatically generating Python type annotations in controller files. These annotations can be used for auto-completion, reference and type-checking inside the controller file.

class Person(Document):
    # begin: auto-generated types
    # This code is auto-generated. Do not modify anything in this block.

    from typing import TYPE_CHECKING

    if TYPE_CHECKING:
        from frappe.types import DF

        first_name: DF.Data
        last_name: DF.Data 
        user: DF.Link
    # end: auto-generated types
    pass


Note: These annotations are generated when creating or updating doctypes. If you modify the code block, it will get overridden on the next update.

You can configure automatic exporting in your app by adding the following hook.

# hooks.py

export_python_type_annotations = True
Learn more about type annotations:

https://docs.python.org/3/library/typing.html
VS Code users can install Python extension for better auto-complete - https://code.visualstudio.com/docs/languages/python
Most other editors have an equivalent plugin system using LSP.



Form & View Settings 
View Settings 
Title Field 
A field of the DocType which will be displayed as a title in the Form



Set the title field

Enter the name of a custom field in 'Title Field'



Show Title in Link Fields

You can enable Show Title in Link Fields to display Title instead of Name in the Link Fields in another doctype.



So if a custom field of 'link' type is added in another doctype (or through customize form), then the title of the linked document will be displayed in the field instead of name.



Child / Table DocType 
Up until now we have only seen DocTypes that can have a single value for each field. However, there might be a need for storing multiple records against one record, also known as many-to-one relationships. A Child DocType is doctype which can only be linked to a parent DocType. To make a Child DocType make sure to check Is Child Table while creating the doctype.

Child DocType

To link a Child Doctype to its parent, add another row in Parent Doctype with field type Table and options as Child Table.

Child Table

Child DocType records are directly attached to the parent doc.

>>> person = frappe.get_doc('Person', '000001')
>>> person.as_dict()
{
 'first_name': 'John',
 'last_name': 'Doe',
 'qualifications': [
 {'title': 'Frontend Architect', 'year': '2017'},
 {'title': 'DevOps Engineer', 'year': '2016'},
 ]
}
Child Properties 
Child documents have special properties that define their relationship to their parent :

parent: name of the parent.
parenttype: DocType of the parent.
parentfield: Field in the parent that links this child to it.
idx: Sequence (row).

Single DocType 
A Single DocType is a DocType that has only one instance in the database. It is useful for persisting things like System Settings, which don't make sense to have multiple records.

Single DocType

>>> settings = frappe.get_doc('System Settings')
>>> settings.notification_frequency
'Daily'
Schema 
Single DocTypes are stored in the tabSingles table in the database, with each property having its own record.

Columns:

doctype
field
value

Virtual DocTypes 
Virtual DocType is a feature-extension for DocType which allows developers to create DocTypes with custom data sources and DocType controller. The purpose is to define custom DocTypes in the system without creating a table in the database, while utilizing the frontend, resource APIs, and roles and permissions from the framework.

These Virtual DocTypes function exactly like normal DocTypes in the frontend and are indistinguishable for the end-user, but gives more control to the developer over the DocType's data source. With this, the data source for a Virtual DocType can be anything: an external API, a secondary database, JSON or CSV files, etc. This enables the developers to plug-in database backends other than MariaDB and Postgres, and makes the Frappe Framework even more powerful!

Note: frappe.db.* calls work only with site's database connection. You'll need to implement methods to achieve direct query to data store used by Virtual DocType.

Creating a Virtual DocType 
To create a Virtual DocType, just select the Virtual DocType checkbox while creating the DocType:

Virtual DocType

Creating a Custom Controller 
As an example, the following controller code uses a JSON file as the DocType datasource:

class VirtualDoctype(Document):
    """This is a virtual doctype controller for demo purposes.

 - It uses a single JSON file on disk as "backend".
 - Key is docname and value is the document itself.

 Example:
 {
 "doc1": {"name": "doc1", ...}
 "doc2": {"name": "doc2", ...}
 }
 """

    DATA_FILE = "data_file.json"

 @staticmethod
    def get_current_data() -> dict[str, dict]:
        """Read data from disk"""
        if not os.path.exists(VirtualDoctype.DATA_FILE):
            return {}

        with open(VirtualDoctype.DATA_FILE) as f:
            return json.load(f)

 @staticmethod
    def update_data(data: dict[str, dict]) -> None:
        """Flush updated data to disk"""
        with open(VirtualDoctype.DATA_FILE, "w+") as data_file:
            json.dump(data, data_file)

    def db_insert(self, *args, **kwargs):
        d = self.get_valid_dict(convert_dates_to_str=True)

        data = self.get_current_data()
        data[d.name] = d

        self.update_data(data)

    def load_from_db(self):
        data = self.get_current_data()
        d = data.get(self.name)
        super(Document, self).__init__(d)

    def db_update(self, *args, **kwargs):
        # For this example insert and update are same operation,
        # it might be different for you.
        self.db_insert(*args, **kwargs)

    def delete(self):
        data = self.get_current_data()
        data.pop(self.name, None)
        self.update_data(data)

 @staticmethod
    def get_list(args):
        data = VirtualDoctype.get_current_data()
        return [frappe._dict(doc) for name, doc in data.items()]

 @staticmethod
    def get_count(args):
        data = VirtualDoctype.get_current_data()
        return len(data)

 @staticmethod
    def get_stats(args):
        return {}


You can read about the interface requriements and explanation in the interface file. To integrate other datasources with the Virtual DocType, you will need to add controller methods defining the database access.

Outcome 
The frontend for Virtual DocTypes remain unchanged

Virtual DocType Form

All the /api/resource methods defined by the framework are compatible with Virtual DocTypes.

Added in Version 13

Actions and Links 
Added in Version 12.1

Action and Links (also called Connections) are two ways to provide the end user more interaction with the document. The image below shows what they are :

Action and Link View

Actions 
A DocType may have some DocType Action that will result in a button creation on the DocType View. Supported actions are:

Server Action: This will trigger a whitelisted server action.
Route: This will redirect to a given route.
Configuration of Action 
Action Configuraton

Configuration of Action in custom app 
To call an Action in you own app, you will need a python function decorated with frappe.whitelist :

import frappe

@frappe.whitelist()
def execute_function(*args,**kwargs):
    """
 This fonction will be executed when the Execute Action Button will be clicked
 """
    print('Hello World')
    # The data is transmitted via keyword argument
    print(kwargs)


This code should go somewhere inside you app, typically in a file like apps/my_app/my_app/api.py

And then, configure the correspondant Action path :

Custom Action Configuraton

Connections (Linked Documents) 
A standard navigation aid to the DocType view is the Connections section on the dashboard. This helps the viewer identify at a glance which document types are connected to this DocType and can quickly create new related documents.

These links also support adding internal links (links to DocType in child tables).

Configuration Connections 
Link Configuration

Internal Link

Via script 
To configure connections for a doctype in your app, create a get_data() function inside <doctype>_dashboard.py. Here's an example from the sales_invoice_dashboard.py of the Sales Invoice doctype from ERPNext:

from frappe import _


def get_data():
    return {
        "fieldname": "sales_invoice",
        "non_standard_fieldnames": {
            "Delivery Note": "against_sales_invoice",
            "Journal Entry": "reference_name",
            "Payment Entry": "reference_name",
            "Payment Request": "reference_name",
            "Sales Invoice": "return_against",
            "Auto Repeat": "reference_document",
            "Purchase Invoice": "inter_company_invoice_reference",
        },
        "internal_links": {
            "Sales Order": ["items", "sales_order"],
            "Timesheet": ["timesheets", "time_sheet"],
        },
        "internal_and_external_links": {
            "Delivery Note": ["items", "delivery_note"],
        },
        "transactions": [
            {
                "label": _("Payment"),
                "items": [
                    "Payment Entry",
                    "Payment Request",
                    "Journal Entry",
                    "Invoice Discounting",
                    "Dunning",
                ],
            },
            {"label": _("Reference"), "items": ["Timesheet", "Delivery Note", "Sales Order"]},
            {"label": _("Returns"), "items": ["Sales Invoice"]},
            {"label": _("Subscription"), "items": ["Auto Repeat"]},
            {"label": _("Internal Transfers"), "items": ["Purchase Invoice"]},
        ],
    }
transactions define all the connections and the respective groups to put them under.
internal_links define the connections where the doctype has internal links. For example, Sales Invoice has internal links through its Item child table to the Sales Order doctype.
internal_and_external_links define the connections where the doctype has both internal and external links. For example, Sales Invoice has internal links through its Item child table to the Delivery Note doctype and Sales Invoice also has external links to the Delivery Note doctype through its Item child table.
fieldname defines the default fieldname to be searched while finding external links for the doctype.
non_standard_fieldnames define the fieldnames and their respective doctypes to be searched while finding external links for the doctype.
This would result in the following connections:



Customization of Actions and Links 
DocType Actions and Links are extensible via Customize Form

Customizing DocTypes 
If you are using the same application for multiple site (tenants), each site may want specific customization on top of the DocType. For example if you have a "Customer" DocType each user may want addition Custom Fields or naming or other configuration that would be specific to them.

To allow for site-specific customization, Frappe Framework has multiple approaches

Custom Field: A DocType that keeps track of site-specific fields.
Property Setter: This keeps track of specific properties that are overridden in DocType and its children.
Customize Form: A view that helps you easily customize DocTypes
Client Script: Additional client-side event handlers.
Server Script: Additional server-side business logic.
Custom DocPerm: Additional Permission (handled via Role Permission Manager)
Customize Form 
Customize Form is a view that helps you override properties of a DocType and add Custom Fields via a single view.

Customize Form

When you change any properties of the DocType via Customize Form, it will not change the underlying DocType but add new custom objects to override those properties. This is done in a seamless manner.

Adding Custom Links and Actions 
Added in Version 13

You can also add / edit Links and Actions via Customize Form. These changes are saved in the same DocTypes (DocType Link and DocType Action) but with a custom property checked.

These addtional (custom) configurations are automatically applied when metadata is fetched via frappe.get_meta.

Data Masking 
Note: This feature is only available in nightly (v16) version. This feature is considered experimental.

In the Frappe Framework, permissions can be applied to control field visibility using Perm Levels.

However, in many business scenarios, it's important to show certain fields while hiding their sensitive data. For example:

HR users might need to view employee details but should not see salary amounts.
Support staff may see customer phone numbers in a masked format like 811XXXXXXX.
Finance users can view bank account fields without exposing the full account number.
This is where Data Masking comes in.

With Data Masking, you can configure specific fields to display masked or hidden values based on the user's roles and permissions — without restricting field visibility.
It ensures sensitive information remains protected while keeping the user interface consistent and informative.

Enabling Data Masking 
Data Masking can be enabled directly from the Doctype or through the Customize Form.

Steps to Enable Data Masking 
Open the Doctype (in Developer Mode) or Customize Form where you want to enable masking.
Select the field you want to mask.
Check the Mask checkbox.
Save and reload the form.
Once enabled, users who do not have the Mask permission for that field will see masked or hidden data, while users with the appropriate permission will see the actual value.

Here's a quick demo showing how to enable Data Masking: Enable Data Masking

Supported Field Types 
Data Masking can be applied only on the following field types:

Select, Read Only, Phone, Percent, Password, Link, Int, Float,
Dynamic Link, Duration, Datetime, Currency, Data, and Date.

For Developers 
Data Masking in the Frappe Framework works seamlessly with the existing permission system.
When a user doesn’t have the required Mask permission for a field, the framework automatically replaces the actual value with a masked version both in the UI and backend responses.

How It Works Internally 
Field Configuration
Each field can have a mask property enabled in its DocField.
{
    "fieldname": "phone_number",
    "fieldtype": "Data",
    "options": "Phone",
    "mask": 1
}
Permission Check
The system checks if the current user has the mask permission for that field using:
meta.has_permlevel_access_to(fieldname=df.fieldname, df=df, permission_type="mask")
Automatic Masking in Responses Once the permission check fails, the framework automatically masks the field value before returning it. This applies to:

Form view data loading
List view queries
Reports using ORM or standard data fetching
API responses (e.g. /api/resource/..., /api/method/...)
Note: Data Masking does not apply automatically to custom SQL queries or Query Reports that use raw SQL. In such cases, developers need to explicitly apply masking logic in their query results before returning the response.

Permission Types 
Note: This feature is experimental and available on develop/nightly builds.

In the Frappe Framework, there are built-in permission types such as read, write, create, delete, and submit. Some applications, however, need more granular, action-specific permissions (for example: "download file", "impersonate user", or "approve record").

Custom Permission Types let you declare new permission flags that behave like the standard permission types, but map to custom actions in your app.

Overview 
What it does: Adds a named permission type that can be assigned to roles for one or more DocTypes.
Where it's stored: A Permission Type record is exported into your app under the module, typically at your_app/your_module/permission_type/<name>.json.
How it's used: Use Role Permission Manager to assign the custom permission to roles for the selected DocType(s). In your code, check permissions using frappe.has_permission(doc, "<custom_permission_name>").
Creating a Permission Type 
Enable developer mode on the site and log in as Administrator.
Create a new Permission Type via the desk UI. Provide:
Name — a unique identifier (e.g. comment, approve, download).
DocType — the DocType to which this permission type will apply.
Save the record. Exported fixtures are included when your app is installed on another site.
After creating the permission type, use the Role Permission Manager to grant that permission to roles for the selected DocType, just like built-in permission types.

Then you can simply check for the custom permission in your code to control access to the associated action:

if frappe.has_permission(doc, "comment"):
    # permit the custom action (e.g., create a comment)
    create_comment_for(doc, user)
else:
    frappe.throw("Not permitted", frappe.PermissionError)